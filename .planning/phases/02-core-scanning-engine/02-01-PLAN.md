---
phase: 02-core-scanning-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/scanner/mod.rs
  - src-tauri/src/scanner/types.rs
  - src-tauri/src/scanner/ip_range.rs
  - src-tauri/src/scanner/ports.rs
  - src-tauri/src/scanner/services.rs
autonomous: true

must_haves:
  truths:
    - "IP ranges in CIDR format (192.168.1.0/24) parse into valid IP lists"
    - "IP ranges in start-end format (192.168.1.1-192.168.1.254) parse into valid IP lists"
    - "Port presets Simple, Full, AI Ports, and Custom return correct port lists"
    - "Service name lookup returns human-readable names for known ports"
  artifacts:
    - path: "src-tauri/src/scanner/types.rs"
      provides: "ScanConfig, ScanResult, HostResult, PortResult, ScanProgress types"
      exports: ["ScanConfig", "ScanResult", "HostResult", "PortResult", "ScanProgress", "PortPreset"]
    - path: "src-tauri/src/scanner/ip_range.rs"
      provides: "CIDR and start-end IP range parsing"
      exports: ["parse_ip_range"]
    - path: "src-tauri/src/scanner/ports.rs"
      provides: "Port preset definitions and custom port parsing"
      exports: ["get_port_list", "PortPreset", "TOP_100_PORTS", "AI_PORTS"]
    - path: "src-tauri/src/scanner/services.rs"
      provides: "Port-to-service-name mapping"
      exports: ["get_service_name"]
    - path: "src-tauri/src/scanner/mod.rs"
      provides: "Scanner module re-exports"
  key_links:
    - from: "src-tauri/Cargo.toml"
      to: "cidr crate"
      via: "dependency declaration"
      pattern: 'cidr = "0.3"'
    - from: "src-tauri/src/scanner/ip_range.rs"
      to: "cidr crate"
      via: "use cidr::Ipv4Cidr"
      pattern: "use cidr::Ipv4Cidr"
---

<objective>
Create the Rust scanner module foundation: shared types, IP range parsing (CIDR + start-end), port presets, and service name mapping. Add new crate dependencies.

Purpose: All scan engine code (ping, port, orchestration) depends on shared types and utilities. This plan establishes the data layer that Plans 02-04 build on.
Output: `src-tauri/src/scanner/` module with types, IP parsing, port presets, and service names.
</objective>

<execution_context>
@C:\Users\jfago\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jfago\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-scanning-engine/02-RESEARCH.md
@src-tauri/Cargo.toml
@src-tauri/src/lib.rs
@src-tauri/src/commands/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and create scanner types module</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/scanner/mod.rs
    src-tauri/src/scanner/types.rs
  </files>
  <action>
    1. Add new dependencies to src-tauri/Cargo.toml:
       - cidr = "0.3"
       - hickory-resolver = "0.24"
       - tokio-util = { version = "0.7", features = ["sync"] }

    2. Create src-tauri/src/scanner/mod.rs that declares ALL submodules upfront (including those created by later plans, to avoid parallel file conflicts):
       - pub mod types;
       - pub mod ip_range;
       - pub mod ports;
       - pub mod services;
       - pub mod dns;       // Created by Plan 02-02
       - pub mod ping;      // Created by Plan 02-02
       - pub mod portscan;  // Created by Plan 02-03

       Also create empty stub files for the modules created by later plans so the build doesn't fail:
       - src-tauri/src/scanner/dns.rs (empty, just a comment "// Implemented in Plan 02-02")
       - src-tauri/src/scanner/ping.rs (empty, just a comment "// Implemented in Plan 02-02")
       - src-tauri/src/scanner/portscan.rs (empty, just a comment "// Implemented in Plan 02-03")

    3. Create src-tauri/src/scanner/types.rs with these Serde-serializable types:

       PortPreset enum: Simple, Full, AiPorts, Custom

       ScanConfig struct:
       - ip_range: String (raw user input, parsed later)
       - port_preset: PortPreset
       - custom_ports: Option<Vec<u16>>
       - timeout_ms: u64 (default 500)
       - concurrency: usize (default 50)

       PortResult struct:
       - port: u16
       - service: String (human-readable name)

       HostResult struct:
       - ip: String
       - hostname: Option<String>
       - open_ports: Vec<PortResult>
       - is_alive: bool (responded to ping)

       ScanProgress enum (tagged union via serde tag = "type"):
       - Started { total_hosts: usize }
       - HostDiscovered { ip: String, hostname: Option<String> }
       - HostScanned { ip: String, hostname: Option<String>, open_ports: Vec<PortResult> }
       - Progress { scanned: usize, total: usize, percent: f32 }
       - Completed { total_hosts: usize, hosts_alive: usize, duration_ms: u64 }
       - Cancelled { scanned: usize, total: usize }
       - Error { message: String }

       All types derive Clone, Debug, Serialize, Deserialize.

    4. Register the scanner module in src-tauri/src/lib.rs by adding `mod scanner;` at the top (do NOT modify any existing code or command registrations yet -- just the module declaration).
  </action>
  <verify>
    Run `cargo check` in src-tauri directory. All types should compile without errors. The scanner module should be visible.
  </verify>
  <done>
    Cargo.toml has cidr, hickory-resolver, tokio-util deps. scanner/types.rs compiles with all types serializable. scanner/mod.rs re-exports submodules.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement IP range parsing</name>
  <files>
    src-tauri/src/scanner/ip_range.rs
  </files>
  <action>
    Create src-tauri/src/scanner/ip_range.rs implementing a single public function:

    pub fn parse_ip_range(input: &str) -> Result<Vec<Ipv4Addr>, String>

    This function auto-detects the format and parses accordingly:

    1. If input contains '/' -> parse as CIDR using cidr::Ipv4Cidr::from_str.
       - Iterate using cidr.iter().map(|inet| inet.address()).collect()
       - For /24 and larger, skip network address (.0) and broadcast address (.255)
       - Handle /32 (single IP) and /31 (two IPs) correctly without skipping

    2. If input contains '-' -> parse as start-end range.
       - Split on '-', parse each half as Ipv4Addr
       - Support both "192.168.1.1-192.168.1.254" (full IP-full IP) and "192.168.1.1-254" (short form where end is just last octet)
       - Convert to u32, iterate inclusive range, convert back to Ipv4Addr
       - Validate start <= end

    3. Otherwise -> try parsing as single IP, return vec of one.

    4. If none match, return Err with descriptive message.

    Trim whitespace from input before parsing.
  </action>
  <verify>
    Run `cargo check` in src-tauri. Write a #[cfg(test)] mod at the bottom of ip_range.rs with tests:
    - parse_ip_range("192.168.1.0/24") returns 254 IPs (no .0 or .255)
    - parse_ip_range("10.0.0.1-10.0.0.5") returns 5 IPs
    - parse_ip_range("10.0.0.1-5") returns 5 IPs (short form)
    - parse_ip_range("192.168.1.1/32") returns 1 IP
    - parse_ip_range("invalid") returns Err
    Run `cargo test --lib` in src-tauri to verify all pass.
  </verify>
  <done>
    parse_ip_range handles CIDR, start-end, short-form, and single IP. All unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement port presets and service name mapping</name>
  <files>
    src-tauri/src/scanner/ports.rs
    src-tauri/src/scanner/services.rs
  </files>
  <action>
    1. Create src-tauri/src/scanner/ports.rs:

       Define TOP_100_PORTS as pub const &[u16] with the top 100 most common TCP ports (from nmap's top-100 list):
       7, 9, 13, 21, 22, 23, 25, 26, 37, 53, 79, 80, 81, 88, 106, 110, 111, 113, 119, 135, 139, 143, 144, 179, 199, 389, 427, 443, 444, 445, 465, 513, 514, 515, 543, 544, 548, 554, 587, 631, 646, 873, 990, 993, 995, 1025, 1026, 1027, 1028, 1029, 1110, 1433, 1720, 1723, 1755, 1900, 2000, 2001, 2049, 2121, 2717, 3000, 3128, 3306, 3389, 3986, 4899, 5000, 5009, 5051, 5060, 5101, 5190, 5357, 5432, 5631, 5666, 5800, 5900, 6000, 6001, 6646, 7070, 8000, 8008, 8009, 8080, 8081, 8443, 8888, 9100, 9999, 10000, 32768, 49152, 49153, 49154, 49155, 49156, 49157

       Define AI_PORTS as pub const &[u16]:
       11434 (Ollama), 1234 (LM Studio), 8888 (Jupyter), 8000 (vLLM), 6006 (TensorBoard), 5000 (MLflow), 7860 (Gradio), 8501 (Streamlit), 3000 (ComfyUI alternate), 8188 (ComfyUI), 7681 (text-generation-webui), 5001 (LocalAI), 8080 (generic AI), 9090 (Prometheus/ML monitoring)

       Implement:
       pub fn get_port_list(preset: &PortPreset, custom_ports: Option<&[u16]>) -> Vec<u16>
       - PortPreset::Simple -> TOP_100_PORTS.to_vec()
       - PortPreset::Full -> (1u16..=65535).collect()
       - PortPreset::AiPorts -> AI_PORTS.to_vec()
       - PortPreset::Custom -> custom_ports.unwrap_or(&[]).to_vec()

       Also implement:
       pub fn parse_custom_ports(input: &str) -> Result<Vec<u16>, String>
       - Parse comma-separated ports: "80,443,8080"
       - Parse ranges: "1-1024"
       - Parse mixed: "80,443,8000-9000"
       - Validate each port is 1-65535
       - Deduplicate and sort

    2. Create src-tauri/src/scanner/services.rs:

       Implement pub fn get_service_name(port: u16) -> &'static str using a match statement.

       Cover at minimum these services (about 60 entries):
       - Standard: FTP(21), SSH(22), Telnet(23), SMTP(25), DNS(53), HTTP(80), POP3(110), NTP(123), IMAP(143), SNMP(161), LDAP(389), HTTPS(443), SMB(445), SMTP/S(465), IMAPS(993), POP3S(995), MSSQL(1433), Oracle(1521), MySQL(3306), RDP(3389), PostgreSQL(5432), Redis(6379), VNC(5900), HTTP-Proxy(8080)
       - AI-specific: Ollama(11434), LM Studio(1234), Jupyter(8888), vLLM(8000), TensorBoard(6006), MLflow(5000), Gradio(7860), Streamlit(8501), ComfyUI(8188), text-gen-webui(7681), LocalAI(5001)
       - Other common: MongoDB(27017), Elasticsearch(9200), RabbitMQ(5672), Memcached(11211), Kubernetes(6443), Docker(2375/2376), Grafana(3000), Prometheus(9090)
       - Default: "Unknown" for unrecognized ports
  </action>
  <verify>
    Run `cargo check` in src-tauri. Add #[cfg(test)] tests in both files:
    - get_port_list(Simple) returns 100 ports
    - get_port_list(Full) returns 65535 ports
    - get_port_list(AiPorts) includes 11434
    - parse_custom_ports("80,443,8000-8002") returns [80, 443, 8000, 8001, 8002]
    - get_service_name(22) returns "SSH"
    - get_service_name(11434) returns "Ollama"
    - get_service_name(99999) returns "Unknown" (invalid port but function handles gracefully)
    Run `cargo test --lib` in src-tauri to verify all pass.
  </verify>
  <done>
    Port presets return correct lists. Custom port parsing handles commas, ranges, and mixed. Service name mapping covers standard + AI ports. All unit tests pass.
  </done>
</task>

</tasks>

<verification>
- `cargo check` succeeds with no warnings related to scanner module
- `cargo test --lib` passes all tests in ip_range, ports, and services modules
- scanner/mod.rs re-exports all submodules
- Types in types.rs are all Clone + Serialize + Deserialize
</verification>

<success_criteria>
- New dependencies (cidr, hickory-resolver, tokio-util) added to Cargo.toml and compile
- parse_ip_range handles CIDR, start-end, short-form, single IP with tested edge cases
- Port presets (Simple=100, Full=65535, AiPorts=14, Custom) all return correct lists
- Service name mapping returns human-readable names for 60+ ports including AI services
- All unit tests pass via `cargo test --lib`
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-scanning-engine/02-01-SUMMARY.md`
</output>
