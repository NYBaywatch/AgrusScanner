---
phase: 02-core-scanning-engine
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - src-tauri/src/commands/scan.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Frontend can invoke a ping sweep scan and receive streamed progress via Channel"
    - "Frontend can invoke a port scan and receive streamed results via Channel"
    - "Frontend can cancel a running scan and it stops within seconds"
    - "Scan configuration (timeout, concurrency, port preset, IP range) is accepted from frontend"
    - "Progress updates are batched at ~100ms to prevent memory leaks"
  artifacts:
    - path: "src-tauri/src/commands/scan.rs"
      provides: "Tauri commands for scan orchestration with Channel streaming"
      exports: ["start_ping_sweep", "start_port_scan", "cancel_scan"]
    - path: "src-tauri/src/commands/mod.rs"
      provides: "Updated command module re-exports"
    - path: "src-tauri/src/lib.rs"
      provides: "Updated command registration with scan commands and managed state"
  key_links:
    - from: "src-tauri/src/commands/scan.rs"
      to: "src-tauri/src/scanner/ping.rs"
      via: "ping_sweep function call"
      pattern: "ping_sweep"
    - from: "src-tauri/src/commands/scan.rs"
      to: "src-tauri/src/scanner/portscan.rs"
      via: "scan_host_ports/scan_multiple_hosts call"
      pattern: "scan_host_ports|scan_multiple_hosts"
    - from: "src-tauri/src/commands/scan.rs"
      to: "tauri::ipc::Channel"
      via: "progress streaming to frontend"
      pattern: "Channel<ScanProgress>"
    - from: "src-tauri/src/commands/scan.rs"
      to: "CancellationToken"
      via: "shared state for cancellation"
      pattern: "cancel_token"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/commands/scan.rs"
      via: "invoke_handler registration"
      pattern: "start_ping_sweep|start_port_scan|cancel_scan"
---

<objective>
Create Tauri commands that wire the ping sweep and port scan engines to the frontend via Channel-based progress streaming, managed state for cancellation, and batched progress updates.

Purpose: This is the integration layer -- connecting Rust scan engines to the Tauri IPC bridge so the React frontend can start/cancel scans and receive real-time results. The critical concerns are memory-safe progress streaming and thread-safe cancellation.
Output: Three new Tauri commands (start_ping_sweep, start_port_scan, cancel_scan) registered and ready for frontend invocation.
</objective>

<execution_context>
@C:\Users\jfago\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jfago\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-scanning-engine/02-RESEARCH.md
@.planning/phases/02-core-scanning-engine/02-01-SUMMARY.md
@src-tauri/src/lib.rs
@src-tauri/src/commands/mod.rs
@src-tauri/src/scanner/types.rs
@src-tauri/src/scanner/ping.rs
@src-tauri/src/scanner/portscan.rs
@src-tauri/src/scanner/dns.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scan command with managed state and cancellation</name>
  <files>
    src-tauri/src/commands/scan.rs
    src-tauri/src/commands/mod.rs
  </files>
  <action>
    Create src-tauri/src/commands/scan.rs:

    1. Define managed state struct:

       pub struct ScanState {
           pub cancel_token: Mutex<Option<CancellationToken>>,
           pub is_scanning: Mutex<bool>,
       }

       impl Default for ScanState { ... } // None, false

    2. Implement cancel_scan command:

       #[tauri::command]
       pub fn cancel_scan(state: State<'_, ScanState>) -> Result<(), String>
       - Lock cancel_token mutex
       - If Some(token), call token.cancel()
       - If None, return Err("No active scan to cancel")

    3. Implement start_ping_sweep command:

       #[tauri::command]
       pub async fn start_ping_sweep(
           range: String,
           timeout_ms: u64,
           concurrency: usize,
           on_progress: Channel<ScanProgress>,
           state: State<'_, ScanState>,
       ) -> Result<(), String>

       Implementation:
       a. Check is_scanning -- if true, return Err("Scan already in progress")
       b. Set is_scanning = true
       c. Parse IP range using parse_ip_range(&range)
       d. Create new CancellationToken, store in state
       e. Send ScanProgress::Started { total_hosts: ips.len() }
       f. Track timing with std::time::Instant::now()
       g. Call ping_sweep(ips, timeout_ms, concurrency, cancel_token.clone(), callback)
          - The callback should batch-send ScanProgress::HostDiscovered for alive hosts
          - Track scanned count, send ScanProgress::Progress every 100ms (use last_update Instant)
       h. After sweep completes, call batch_reverse_dns on alive hosts
       i. Send ScanProgress::HostDiscovered for each host with resolved hostname
       j. Send ScanProgress::Completed or ScanProgress::Cancelled based on token state
       k. Clear cancel_token from state, set is_scanning = false
       l. Use a scopeguard pattern or manual finally block to ALWAYS reset is_scanning = false, even on error/panic.

    4. Implement start_port_scan command:

       #[tauri::command]
       pub async fn start_port_scan(
           range: String,
           port_preset: String,
           custom_ports: Option<String>,
           timeout_ms: u64,
           concurrency: usize,
           on_progress: Channel<ScanProgress>,
           state: State<'_, ScanState>,
       ) -> Result<(), String>

       Implementation:
       a. Same is_scanning guard as ping sweep
       b. Parse IP range
       c. Parse port_preset string to PortPreset enum (match "simple"|"full"|"ai_ports"|"custom")
       d. If custom preset, parse custom_ports string using parse_custom_ports
       e. Get port list using get_port_list
       f. Create CancellationToken, store in state
       g. Send ScanProgress::Started
       h. For each host (or use scan_multiple_hosts):
          - Scan ports with cancellation
          - Resolve hostname with reverse_dns_lookup
          - Send ScanProgress::HostScanned with full results
          - Batch ScanProgress::Progress updates at 100ms intervals
       i. Send Completed/Cancelled
       j. Reset state

       IMPORTANT: Progress batching -- do NOT send Progress for every single port checked. Track scanned count internally and emit Progress at most every 100ms using Instant::elapsed check.

    Update src-tauri/src/commands/mod.rs:
    - Add `pub mod scan;`
    - Add re-exports: `pub use scan::{start_ping_sweep, start_port_scan, cancel_scan};`
  </action>
  <verify>
    Run `cargo check` in src-tauri. All three commands should compile with correct Tauri attribute macros and type signatures.
  </verify>
  <done>
    Three Tauri commands created: start_ping_sweep (ICMP sweep with DNS), start_port_scan (TCP scan with presets), cancel_scan (graceful stop). All use managed ScanState for cancellation. Progress streamed via Channel with 100ms batching. is_scanning guard prevents concurrent scans.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register commands and managed state in lib.rs</name>
  <files>
    src-tauri/src/lib.rs
  </files>
  <action>
    Update src-tauri/src/lib.rs:

    1. Add imports for the new scan commands from commands module.

    2. Add ScanState to Tauri managed state:
       .manage(commands::scan::ScanState::default())

    3. Register new commands in invoke_handler:
       Add start_ping_sweep, start_port_scan, cancel_scan to the existing generate_handler! macro alongside the 4 existing platform commands.

    The final invoke_handler should register all 7 commands:
    - check_npcap_installed (existing)
    - check_firewall_blocks_icmp (existing)
    - check_admin_privileges (existing)
    - get_local_subnet (existing)
    - start_ping_sweep (new)
    - start_port_scan (new)
    - cancel_scan (new)

    IMPORTANT: Do NOT modify any existing command code or platform.rs. Only add the new registrations and state management.
  </action>
  <verify>
    Run `cargo build` in src-tauri (full build, not just check). All 7 commands registered. No compilation errors. The binary should start successfully (test with `cargo run` if practical, or just verify build succeeds).
  </verify>
  <done>
    lib.rs registers all 7 Tauri commands (4 platform + 3 scan). ScanState managed as shared state. Application compiles and can start.
  </done>
</task>

</tasks>

<verification>
- `cargo build` succeeds in src-tauri with no errors
- All 7 commands registered in invoke_handler
- ScanState managed with Default implementation
- Channel<ScanProgress> used (not Tauri Events) for streaming
- Progress batched at 100ms intervals (not per-host/per-port)
- CancellationToken stored in state and accessible by cancel_scan
- is_scanning guard prevents concurrent scan execution
- State always cleaned up (cancel_token cleared, is_scanning reset) even on error
</verification>

<success_criteria>
- start_ping_sweep: accepts range/timeout/concurrency, streams HostDiscovered + Progress, resolves hostnames
- start_port_scan: accepts range/preset/custom_ports/timeout/concurrency, streams HostScanned + Progress
- cancel_scan: cancels active scan, triggers Cancelled progress event
- No memory leaks from unbatched progress events
- Concurrent scan attempts rejected with error message
- Clean state reset after scan completes/cancels/errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-scanning-engine/02-04-SUMMARY.md`
</output>
