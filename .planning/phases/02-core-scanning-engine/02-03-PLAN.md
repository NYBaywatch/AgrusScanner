---
phase: 02-core-scanning-engine
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src-tauri/src/scanner/portscan.rs
autonomous: true

must_haves:
  truths:
    - "TCP port scan detects open ports on a target host"
    - "Port scanning runs concurrently with bounded semaphore"
    - "Port scan respects cancellation token and stops gracefully"
    - "Open ports are returned with their service names"
  artifacts:
    - path: "src-tauri/src/scanner/portscan.rs"
      provides: "Concurrent TCP port scanning engine"
      exports: ["scan_host_ports", "scan_single_port"]
  key_links:
    - from: "src-tauri/src/scanner/portscan.rs"
      to: "tokio::net::TcpStream"
      via: "async TCP connect"
      pattern: "TcpStream::connect"
    - from: "src-tauri/src/scanner/portscan.rs"
      to: "tokio::sync::Semaphore"
      via: "bounded concurrency"
      pattern: "Semaphore::new"
    - from: "src-tauri/src/scanner/portscan.rs"
      to: "src-tauri/src/scanner/services.rs"
      via: "port-to-service-name lookup"
      pattern: "get_service_name"
    - from: "src-tauri/src/scanner/portscan.rs"
      to: "tokio_util::sync::CancellationToken"
      via: "cooperative cancellation"
      pattern: "CancellationToken"
---

<objective>
Implement the TCP port scanning engine with bounded concurrency, per-port timeouts, cancellation support, and service name resolution.

Purpose: Port scanning is the core feature of the scanner. It must handle scanning from 1 port to 65535 ports per host efficiently without exhausting system resources.
Output: `scanner/portscan.rs` -- standalone port scan engine ready for Tauri command integration in Plan 04.
</objective>

<execution_context>
@C:\Users\jfago\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jfago\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-scanning-engine/02-RESEARCH.md
@src-tauri/src/scanner/types.rs
@src-tauri/src/scanner/ports.rs
@src-tauri/src/scanner/services.rs
@src-tauri/src/scanner/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement single-port TCP connect scan</name>
  <files>
    src-tauri/src/scanner/portscan.rs
    src-tauri/src/scanner/mod.rs
  </files>
  <action>
    Create src-tauri/src/scanner/portscan.rs:

    Implement the atomic port check:

    pub async fn scan_single_port(ip: Ipv4Addr, port: u16, timeout_ms: u64) -> Option<PortResult>

    Implementation:
    1. Construct SocketAddr from ip and port.
    2. Use tokio::time::timeout wrapping tokio::net::TcpStream::connect(&addr).
    3. If connection succeeds within timeout -> return Some(PortResult { port, service: get_service_name(port).to_string() })
    4. If timeout elapses or connection refused -> return None
    5. Do NOT log individual port failures (too noisy for full scans).

    NOTE: scanner/mod.rs already declares `pub mod portscan;` (added by Plan 02-01). Just replace the stub file with the real implementation.
  </action>
  <verify>
    Run `cargo check` in src-tauri. Function signature compiles and uses PortResult from types.rs and get_service_name from services.rs.
  </verify>
  <done>
    scan_single_port performs TCP connect scan on one port with timeout, returns PortResult with service name on success, None on failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement concurrent multi-port host scanner</name>
  <files>
    src-tauri/src/scanner/portscan.rs
  </files>
  <action>
    Add to src-tauri/src/scanner/portscan.rs:

    Implement the multi-port scanner for a single host:

    pub async fn scan_host_ports(
        ip: Ipv4Addr,
        ports: Vec<u16>,
        timeout_ms: u64,
        concurrency: usize,
        cancel_token: CancellationToken,
        on_port_found: Option<Arc<dyn Fn(Ipv4Addr, PortResult) + Send + Sync>>,
    ) -> Vec<PortResult>

    Implementation:
    1. Create Semaphore with min(concurrency, 100) permits (cap for safety per research).
    2. For each port in ports:
       a. Check cancel_token.is_cancelled(). If cancelled, break.
       b. Clone semaphore, cancel_token.
       c. Spawn tokio task:
          - Acquire semaphore permit (owned)
          - Use tokio::select! { _ = cancel_token.cancelled() => None, result = scan_single_port(ip, port, timeout_ms) => result }
          - If port is open and on_port_found callback exists, call it
          - Return the Option<PortResult>
    3. Await all JoinHandles, collect Some results into Vec<PortResult>.
    4. Sort results by port number before returning.

    Also implement a batch scanner for multiple hosts:

    pub async fn scan_multiple_hosts(
        hosts: Vec<Ipv4Addr>,
        ports: Vec<u16>,
        timeout_ms: u64,
        concurrency: usize,
        cancel_token: CancellationToken,
        on_host_complete: impl Fn(Ipv4Addr, Vec<PortResult>) + Send + Sync + 'static,
    ) -> Vec<HostResult>

    Implementation:
    1. For full scan (65535 ports) the concurrency is per-host, hosts are scanned one at a time to avoid total socket explosion.
    2. For smaller port lists, scan hosts concurrently using a host-level semaphore (concurrency / ports.len() hosts at a time, minimum 1).
    3. For each host:
       a. Check cancel_token.is_cancelled(), break if so.
       b. Call scan_host_ports for that host.
       c. Call on_host_complete callback with results.
       d. Build HostResult { ip, hostname: None (DNS done elsewhere), open_ports, is_alive: !open_ports.is_empty() }
    4. Return collected HostResults.

    IMPORTANT:
    - The concurrency parameter is the TOTAL concurrent connections across all operations, NOT per-host.
    - For Full scan (65535 ports), scanning hosts sequentially with per-host concurrency is correct.
    - For Simple scan (100 ports), multiple hosts can scan in parallel.
    - Never exceed 100 total concurrent TCP connections.
  </action>
  <verify>
    Run `cargo check` in src-tauri. Write #[cfg(test)] tests:
    - scan_host_ports with empty port list returns empty vec
    - scan_host_ports with cancelled token returns empty vec immediately
    - scan_single_port to localhost on a likely-closed port (e.g., 19999) returns None
    Run `cargo test --lib` in src-tauri.
  </verify>
  <done>
    scan_host_ports scans multiple ports on one host concurrently with semaphore bounds. scan_multiple_hosts orchestrates across hosts with intelligent concurrency distribution. Both respect cancellation. Open ports returned with service names, sorted by port number.
  </done>
</task>

</tasks>

<verification>
- `cargo check` succeeds with portscan module
- `cargo test --lib` passes all tests
- Semaphore used (not FuturesUnordered) for concurrency
- All TcpStream::connect calls wrapped with tokio::time::timeout
- CancellationToken checked before each port/host and in tokio::select!
- Total concurrent connections never exceed 100
- Results include service names from services.rs
</verification>

<success_criteria>
- scan_single_port performs async TCP connect with configurable timeout
- scan_host_ports scans all given ports on one host with bounded concurrency
- scan_multiple_hosts orchestrates multi-host scanning with intelligent concurrency
- Cancellation stops scanning within one iteration
- Port results sorted and include human-readable service names
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-scanning-engine/02-03-SUMMARY.md`
</output>
