---
phase: 01-foundation-windows-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - vite.config.ts
  - index.html
  - src/main.tsx
  - src/App.tsx
  - src/components/PlatformStatus.tsx
  - src/hooks/usePlatformChecks.ts
  - src-tauri/Cargo.toml
  - src-tauri/tauri.conf.json
  - src-tauri/src/main.rs
  - src-tauri/src/lib.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/commands/platform.rs
autonomous: true

must_haves:
  truths:
    - "Application launches as Windows desktop executable"
    - "User sees Npcap installation status with download link if missing"
    - "User sees Windows Firewall ICMP status with guidance if blocked"
    - "User sees admin privilege status with restart guidance if not elevated"
    - "IP range field is pre-filled with auto-detected local subnet"
  artifacts:
    - path: "src-tauri/src/commands/platform.rs"
      provides: "Platform detection commands (Npcap, firewall, admin, subnet)"
      exports: ["check_npcap_installed", "check_firewall_blocks_icmp", "check_admin_privileges", "get_local_subnet"]
    - path: "src/components/PlatformStatus.tsx"
      provides: "Platform status display with user guidance"
      min_lines: 80
    - path: "src/hooks/usePlatformChecks.ts"
      provides: "React hook wrapping platform detection commands"
      exports: ["usePlatformChecks"]
    - path: "src-tauri/Cargo.toml"
      contains: "surge-ping"
      provides: "Rust dependencies configured"
  key_links:
    - from: "src/hooks/usePlatformChecks.ts"
      to: "src-tauri/src/commands/platform.rs"
      via: "invoke() calls on mount"
      pattern: "invoke<.*>\\('check_"
    - from: "src/components/PlatformStatus.tsx"
      to: "src/hooks/usePlatformChecks.ts"
      via: "usePlatformChecks hook"
      pattern: "usePlatformChecks\\(\\)"
    - from: "src/App.tsx"
      to: "src/components/PlatformStatus.tsx"
      via: "component rendering"
      pattern: "<PlatformStatus"
---

<objective>
Establish Tauri 2 desktop application foundation with Windows-specific platform detection and user guidance.

Purpose: Create the core application structure and implement Windows platform requirement detection (Npcap, firewall, admin privileges, subnet) so users receive actionable guidance before attempting network operations.

Output: Working Tauri desktop application that launches on Windows, detects all platform requirements, and displays status with user-friendly guidance when requirements are not met.
</objective>

<execution_context>
@C:\Users\jfago\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\jfago\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@D:\Working\Projects\Scanner\.planning\PROJECT.md
@D:\Working\Projects\Scanner\.planning\ROADMAP.md
@D:\Working\Projects\Scanner\.planning\STATE.md
@D:\Working\Projects\Scanner\.planning\phases\01-foundation-windows-integration\01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Tauri Project with React + TypeScript</name>
  <files>
    package.json
    tsconfig.json
    vite.config.ts
    index.html
    src/main.tsx
    src/App.tsx
    src-tauri/Cargo.toml
    src-tauri/tauri.conf.json
    src-tauri/src/main.rs
    src-tauri/src/lib.rs
  </files>
  <action>
    Run `npm create tauri-app@latest` in D:\Working\Projects\Scanner directory with options:
    - Project name: agrus-scanner
    - Framework: React
    - Language: TypeScript
    - Package manager: npm

    After scaffolding, add Rust dependencies to src-tauri/Cargo.toml:
    - tokio = { version = "1.43", features = ["full"] }
    - surge-ping = "0.8"
    - socket2 = "0.5"
    - ipconfig = "0.3"
    - is_elevated = "0.1"
    - serde = { version = "1", features = ["derive"] }
    - serde_json = "1"

    Update src-tauri/tauri.conf.json:
    - Set productName to "Agrus Scanner"
    - Set identifier to "com.agrus.scanner"

    Replace default src/App.tsx with minimal container:
    - Import and render PlatformStatus component (will be created in next task)
    - Basic dark background styling (hacker aesthetic foundation)
    - Remove default Tauri scaffolding demo content

    Run `npm install` to install frontend dependencies.
    Run `cargo build` in src-tauri/ to verify Rust dependencies compile.
  </action>
  <verify>
    cd D:\Working\Projects\Scanner && npm run tauri dev
    Application window should open showing empty dark interface.
    Verify no compilation errors in terminal output.
    Close dev window with Ctrl+C.
  </verify>
  <done>
    - Tauri project structure exists with src/ and src-tauri/ directories
    - package.json lists @tauri-apps dependencies
    - src-tauri/Cargo.toml lists all required Windows detection crates
    - `npm run tauri dev` launches application window successfully
    - Rust backend compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Windows Platform Detection Commands</name>
  <files>
    src-tauri/src/commands/mod.rs
    src-tauri/src/commands/platform.rs
    src-tauri/src/lib.rs
  </files>
  <action>
    Create src-tauri/src/commands/ directory and module structure.

    In src-tauri/src/commands/platform.rs, implement four async Tauri commands following patterns from RESEARCH.md:

    1. check_npcap_installed() -> Result<bool, String>
       - Check if C:\Program Files\Npcap\NPFInstall.exe exists
       - Return true if exists, false otherwise

    2. check_firewall_blocks_icmp() -> Result<bool, String>
       - Execute PowerShell: Get-NetFirewallRule -DisplayName "File and Printer Sharing (Echo Request - ICMPv4-In)" | Select-Object -ExpandProperty Enabled
       - Parse output: if "True" then firewall allows ICMP (return false), otherwise blocks (return true)
       - Handle PowerShell execution errors gracefully

    3. check_admin_privileges() -> bool
       - Use is_elevated::is_elevated() crate
       - Return true if process is elevated, false otherwise

    4. get_local_subnet() -> Result<String, String>
       - Use ipconfig::get_adapters() to enumerate network interfaces
       - Find first adapter with IPv4 address
       - Extract first 3 octets and format as "X.X.X.0/24"
       - Return error if no suitable adapter found

    In src-tauri/src/commands/mod.rs:
    - Declare `pub mod platform;`
    - Re-export all platform commands

    In src-tauri/src/lib.rs:
    - Import commands module
    - Register all four commands in tauri::Builder::default().invoke_handler()
    - Use tauri::generate_handler! macro

    All commands must be marked with #[tauri::command] attribute.
    Use async for I/O operations (firewall check, subnet detection).
    Follow error handling patterns from RESEARCH.md (map_err with descriptive messages).
  </action>
  <verify>
    cargo build in src-tauri/ directory succeeds without warnings.
    Check src-tauri/src/lib.rs contains invoke_handler with all four command names.
    Check src-tauri/src/commands/platform.rs contains #[tauri::command] attributes on all functions.
  </verify>
  <done>
    - src-tauri/src/commands/platform.rs exists with 4 implemented commands
    - All commands are registered in src-tauri/src/lib.rs invoke_handler
    - Rust backend compiles successfully
    - Commands follow async patterns where needed (firewall, subnet)
    - Error handling uses Result<T, String> with descriptive messages
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Platform Status UI with User Guidance</name>
  <files>
    src/hooks/usePlatformChecks.ts
    src/components/PlatformStatus.tsx
    src/App.tsx
  </files>
  <action>
    Create src/hooks/usePlatformChecks.ts React hook:
    - Import invoke from '@tauri-apps/api/core'
    - Define interface PlatformChecks { npcap: boolean; firewall: boolean; elevated: boolean; subnet: string | null; loading: boolean; }
    - In useEffect, call all four platform commands in parallel using Promise.all
    - Store results in state with useState
    - Return checks object
    - No cleanup needed (one-time mount check, not continuous listeners)

    Create src/components/PlatformStatus.tsx:
    - Import usePlatformChecks hook
    - Display loading state while checks run
    - Show four status cards (one per check) with color-coded indicators:
      - Green checkmark if requirement met
      - Yellow/red warning if requirement not met
    - For each failed check, display actionable guidance:
      - Npcap missing: Show download link (https://npcap.com/) with installation instructions
      - Firewall blocks ICMP: Explain how to enable Windows Firewall ICMP rule with PowerShell command or Windows Settings deep link
      - Not elevated: Explain ICMP operations require admin privileges, guide to restart as admin
      - Subnet detection failed: Show manual IP range input field fallback
    - Display detected subnet in read-only field when available
    - Use hacker aesthetic styling: dark background (#0a0a0a), green accent (#00ff41), monospace font (Consolas, Monaco), terminal-inspired layout

    Update src/App.tsx:
    - Import PlatformStatus component
    - Render PlatformStatus at top of application
    - Apply dark theme styling to root container
    - Remove any default Tauri demo content if remaining

    Keep styling inline or in component files (no separate CSS files yet - defer to Phase 4).
  </action>
  <verify>
    npm run tauri dev
    Application launches and immediately runs platform checks.
    Four status indicators appear (may show warnings if requirements not met on dev machine).
    If Npcap missing, download link is visible and clickable.
    If not elevated, guidance message explains admin requirement.
    Detected subnet displays in format "X.X.X.0/24" (or error message if detection failed).
    UI uses dark theme with green accents and monospace font.
  </verify>
  <done>
    - usePlatformChecks hook exists and calls all four platform commands on mount
    - PlatformStatus component displays all four check results with color-coded status
    - Each failed check shows actionable user guidance (download links, instructions, explanations)
    - Detected subnet displays in UI or fallback message shown
    - Hacker aesthetic styling applied (dark background, green accents, monospace)
    - Application launches without errors and platform checks execute automatically
  </done>
</task>

</tasks>

<verification>
Run full application test:
1. `cd D:\Working\Projects\Scanner && npm run tauri dev`
2. Application window opens within 5 seconds
3. Platform status checks execute automatically on load
4. Four status cards display with pass/fail indicators
5. If any checks fail, user guidance is visible and actionable
6. Detected subnet (if available) displays in expected format
7. UI matches hacker aesthetic (dark theme, green, monospace)
8. No console errors in terminal or browser DevTools
9. Application can be closed cleanly with window close button

Test on Windows machine without admin privileges to verify admin check guidance displays correctly.
</verification>

<success_criteria>
**Measurable completion criteria:**

1. **Application launches**: Running `npm run tauri dev` opens desktop window in under 5 seconds with no errors
2. **Npcap detection works**: Status indicator shows green if Npcap installed, red with download link if missing
3. **Firewall detection works**: Status indicator shows ICMP blocking status, provides guidance if blocked
4. **Admin detection works**: Status indicator shows elevation status, explains ICMP requirement if not elevated
5. **Subnet detection works**: Displays detected subnet in "X.X.X.0/24" format or error message if detection fails
6. **User guidance actionable**: Each failed check provides specific next steps (links, commands, explanations)
7. **Hacker aesthetic applied**: Dark background (#0a0a0a), green accents (#00ff41), monospace fonts visible
8. **Build succeeds**: `cargo build` in src-tauri/ completes without errors or warnings

All five success criteria from Phase 1 roadmap must be achievable:
- ✅ Application launches on Windows as desktop executable
- ✅ Application detects Npcap availability and guides user if missing
- ✅ Application detects Windows Firewall ICMP blocking and warns user
- ✅ Application requests admin privileges for ICMP operations when needed (shows status + guidance)
- ✅ Application auto-detects local subnet and pre-fills IP range field
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-windows-integration/01-01-SUMMARY.md` following the summary template with:
- Frontmatter: phase, plan, completed timestamp, duration, files_created, files_modified
- What Was Built section documenting Tauri project structure and platform detection commands
- Key Decisions section noting any implementation choices made
- Technical Details section covering Rust command patterns and React hook integration
- What's Available section listing exported commands and components for Phase 2
</output>
